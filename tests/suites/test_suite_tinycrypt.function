/* BEGIN_HEADER */

#include "tinycrypt/ecc.h"
#include "tinycrypt/ecc_dh.h"
#include "tinycrypt/ecc_dsa.h"

static int uecc_rng_wrapper( uint8_t *dest, unsigned int size )
{
    int ret;
    ret = rnd_std_rand( NULL, dest, size );
    if( ret == 0 )
        return( (int) size );

    return( 0 );
}

/* END_HEADER */

/* BEGIN_DEPENDENCIES
 * depends_on:MBEDTLS_USE_TINYCRYPT
 * END_DEPENDENCIES
 */

/* BEGIN_CASE depends_on:MBEDTLS_USE_TINYCRYPT */
void test_ecdh()
{
    uint8_t private1[NUM_ECC_BYTES] = {0};
    uint8_t private2[NUM_ECC_BYTES] = {0};
    uint8_t public1[2*NUM_ECC_BYTES] = {0};
    uint8_t public2[2*NUM_ECC_BYTES] = {0};
    uint8_t secret1[NUM_ECC_BYTES] = {0};
    uint8_t secret2[NUM_ECC_BYTES] = {0};

    const struct uECC_Curve_t * curve = uECC_secp256r1();

    uECC_set_rng( &uecc_rng_wrapper );

    TEST_ASSERT( uECC_make_key( public1, private1, curve ) != 0 );

    TEST_ASSERT( uECC_make_key( public2, private2, curve ) != 0 );

    TEST_ASSERT( uECC_shared_secret( public2, private1, secret1, curve ) != 0 );

    TEST_ASSERT( uECC_shared_secret( public1, private2, secret2, curve ) != 0 );

    TEST_ASSERT( memcmp( secret1, secret2, sizeof( secret1 ) ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_USE_TINYCRYPT */
void test_ecdsa()
{
    uint8_t private[NUM_ECC_BYTES] = {0};
    uint8_t public[2*NUM_ECC_BYTES] = {0};
    uint8_t hash[NUM_ECC_BYTES] = {0};
    uint8_t sig[2*NUM_ECC_BYTES] = {0};
    unsigned int hash_words[NUM_ECC_WORDS] = {0};

    const struct uECC_Curve_t * curve = uECC_secp256r1();

    uECC_set_rng( &uecc_rng_wrapper );

    uECC_generate_random_int( hash_words, curve->n,
                              BITS_TO_WORDS( curve->num_n_bits ) );

    uECC_vli_nativeToBytes( hash, NUM_ECC_BYTES, hash_words );

    TEST_ASSERT( uECC_make_key( public, private, curve ) != 0 );

    TEST_ASSERT( uECC_sign( private, hash, sizeof( hash ), sig, curve ) != 0 );

    TEST_ASSERT( uECC_verify( public, hash, sizeof( hash ), sig, curve ) != 0 );
}
/* END_CASE */